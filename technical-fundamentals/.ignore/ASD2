/*
  Regretfully, at Silver we do sometimes break our promises.
  We wanted to express this in code, but Javascript's native Promises are not easy to modify.
  We need to implement our own Promises that mimic and extend Javascript's core promises.

  Step 1
  ------
  Implement native style promises with the functions then and catch.
  You can consult the reference at https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise

  Notes:
  - Promise chaining must be supported
  - Then functions carry over resolution values to future calls of the function

  Step 2
  ------
  Implement a "break" method that prevents previous callbacks from being called.
*/

import { Queue } from './ds/Queue';

export class SilverPromise {
  #settled = false;

  #thenCallbacksQueue = new Queue();
  #catchCallbacksQueue = new Queue();
  #valuesQueue = new Queue();
  #errorsQueue = new Queue();

  constructor(callback) {
    callback(this.#resolve.bind(this), this.#reject.bind(this));
  }

  #handleCallback(callback) {
    if (value instanceof Promise) {
      value.then(this.#resolve.bind(this)).catch(this.#resolve.bind(this));
    }

    if (value instanceof Error) {
      this.#errorsQueue.enqueue(value);
    } else {
      this.#valuesQueue.enqueue(value);
    }

    this.#processQueues();
  }

  #resolve(value) {
    if (value instanceof Promise) {
      value.then(this.#resolve.bind(this)).catch(this.#resolve.bind(this));
    }

    if (value instanceof Error) {
      this.#errorsQueue.enqueue(value);
    } else {
      this.#valuesQueue.enqueue(value);
    }

    this.#processQueues();
  }

  #reject(value) {
    this.#errorsQueue.enqueue(value);
    this.#processQueues();
  }

  #processQueues() {}

  then(callback) {
    this.#thenCallbacksQueue.enqueue(callback);
  }

  catch(callback) {
    this.#catchCallbacksQueue.enqueue(callback);
  }
}
